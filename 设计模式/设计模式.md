# 创建型模式

### 简单工厂模式

##### 说明

- 构造工厂类，在调用生产方法时 **传入不同参数来得到不同的产品类对象**
- 依赖于多态

##### 优缺点

- 优点

  - 实现了产品类 **对象创建和使用的分离**

    > 在工厂的生产方法中构造，在调用方法处使用

  - 要获取某个类的对象，只需要知道对应的参数即可

- 缺点

  - 需要引入工厂类

  - 如果要支持 **新的产品类**，需要 **修改生产方法**

    > 因为在生产方法中需要判断到底生成哪个产品类的对象

  - **生产方法为静态方法**，导致工厂类无法继承别的类

##### 示例

- 工厂类

  ```c#
  namespace DesignMethod
  {
      // 增加新产品，需要添加枚举值
      enum ProductIndex
      {
          Computer,
          Phone
      };
  
  
      /// <summary>
      /// 工厂类
      /// </summary>
      public class Factory
      {
          /// <summary>
          /// 生产方法：
          /// </summary>
          /// <returns>Product的子类对象</returns>
          public static Product GetProduct(int index)
          {
              Product ret = null;
              // 增加新产品，需要添加新的case判断
              switch(index)
              {
                  case (int)ProductIndex.Computer:
                      ret = new Computer();
                      break;
                  case (int)ProductIndex.Phone:
                      ret = new Phone();
                      break;
                  default:
                      Console.WriteLine("产品不存在");
                      break;
              }
  
              return ret;
          }
      }
  
  }
  ```

- 产品类
  ```c#
  namespace DesignMethod
  {
      /// <summary>
      /// 此文件保存产品类的定义
      /// </summary>
  
  
      /// <summary>
      /// 产品类抽象
      /// </summary>
      public abstract class Product
      {
          /// <summary>
          /// 产品名称
          /// </summary>
          /// <value>string</value>
          public abstract string Name{get;}
  
  
          /// <summary>
          /// 展示产品信息（）可重写
          /// </summary>
          public virtual void ShowInfo()
          {
              Console.WriteLine("被生产的产品名称：{0}",this.Name);
          }
      }
  
  
      /// <summary>
      /// 产品：电脑
      /// </summary>
      public class Computer : Product
      {
          public override string Name {get {return "Computer";}}
  
          public Computer()
          {
              ShowInfo();
          }
      }
  
  
      /// <summary>
      /// 产品：手机
      /// </summary>
      public class Phone : Product
      {
          public override string Name {get {return "Phone";}}
  
          public Phone()
          {
              ShowInfo();
          }
      }
  }
  ```

- 使用
  ```c#
  class Program
  {
      static void Main(string[] args)
      {
          testFactory();
  
      }
  
      public static void testFactory()
      {
          // 通过传入参数指定生产的产品类型
          Product product = Factory.GetProduct(1);
         	// 被生产的产品名称：Phone
      }
  }
  ```
  
  

### 工厂方法模式

##### 说明

- 定义一个 **工厂接口**，让各个工厂类生产不同的产品
- 使用xml配置文件指定到底是哪个工厂类的对象进行生产

##### 优缺点

- 优点

  - 工厂方法用来创建客户所需要的产品，同时还向客户**隐藏了哪种具体产品类将被实例化这一细节**，用户**只需要关心所需产品对应的工厂**
  - 所有的具体工厂类都具有同一抽象父类，不同产品由不同工厂类负责生产，**分担了原先单独工厂类的复杂度**
  - 添加新产品时，**无需修改现有工厂的生产方法**，只需添加新的产品类和对应的工厂类

- 缺点

  -  在添加新产品时，**需要编写新的具体产品类和与之对应的具体工厂类**，系统中类的个数将成对增加
  - 增加了系统的抽象性和理解难度，且在实现时可能需要用到DOM、反射等技术，增加了系统的实现难度

- 示例

  - Xml
    ```xml
    <?xml version="1.0" encoding="UTF-8"?>
    
    <!-- 通过xml文件指定生产的产品类型 -->
    
    <ProductList>
        <Product type="Phone">6888</Product>
        <Product type="Phone"></Product>
        <Product type="Computer">10000</Product>
        <Product type="Phone"></Product>
        <Product type="Computer"></Product>
    </ProductList>
    ```

  - 使用
    ```c#
    // 读取xml，根据配置生产对应产品
    Console.WriteLine("\n工厂方法：读配置生产");
    XmlDocument document = new XmlDocument();
    document.Load("/Users/dsh/Documents/C.Net/C#_onMac/designMethod/factory/Product.xml");
    
    
    XmlNode productListNode = document.SelectSingleNode("ProductList");
    // 读取子元素，创建对象
    Product[] products = new Product[productListNode.ChildNodes.Count];
    for(int i=0;i<products.Length;i++)
    {
        // 获取创建对象所需参数
        XmlElement productInfo = (XmlElement)productListNode.ChildNodes[i];
        string typeName = productInfo.GetAttribute("type");     // 产品类型名称
        string price = productInfo.InnerText;                   // 产品价格
        if(price.Length<1) price = "1";
        
        // 通过反射创建对象
        Type type = Type.GetType("DesignMethod."+typeName);
        ConstructorInfo ctor = type.GetConstructor(new Type[]{typeof(float)});
        products[i] = (Product)ctor?.Invoke(new object[]{int.Parse(price)});
    }
    ```
    
    

### 抽象工厂模式

##### 说明

- **产品等级结构**：产品类的继承结构

  > 例如：笔记本电脑 --> 拯救者、暗影精灵……

- 产品族：**由同一工厂生产** 的，位于不同产品等级结构中的一组产品

  > 最好是不同产品等级结构同一级的产品
  >
  > 例如：
  >
  > - 联想笔记本产品族：拯救者（性能本产品等级结构）+ ThinkPad（商务本产品等级结构）
  > - 惠普笔记本产品族：暗影精灵 + 光影精灵

- 抽象工厂模式：提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类

  > 一个公司一个工厂，各个公司工厂可以包含多个生产方法

##### 优缺点

- 优点
  - 增加新的产品族很方便，只需要创建新的产品族工厂
  - 系统中有多于一个的产品族，而每次只使用其中某一产品族。可以通过配置文件等方式来使得用户可以动态改变产品族
  -  当一个产品族中的多个对象被设计成一起工作时，它能够保证客户端始终只使用同一个产品族中的对象
- 缺点
  - 增加新的产品等级结构很难，需要修改工厂接口，并逐个修改各个具体的产品族工厂类


##### 示例

> 工厂应能够生产Button、TextField和ComboBox
>
> Spring工厂生产Spring的3种产品，Summer的工厂生产Summer的3种产品

![img](设计模式.assets/SouthEast.jpeg)



### 单例模式

##### 说明

- 确保 **某一个类只有一个实例**
- 在获取实例时，**若实例不存在，能够自动创建**

##### 设计

- 问题：多线程请求实例时可能会导致实例不唯一

- 改进

  - 定义实例变量时直接创建：`private static readonly SingleInstance instance = new SingleInstance();`

    > 添加 `final`或 `readonly` 关键字
    >
    > 调用速度快，但是系统加载时间会变长

  - 添加线程锁定

    > 需要判断线程锁定，性能降低

  - **IoDH** 技术

    > **Initialization Demand Holder** 
    >
    > 在单例类内部定义一个static类，用于保存实例
    >
    > 依赖于语言特性来保证其线程安全

##### 优缺点

- 优点
  - 单例模式提供了 **对唯一/有限数量实例的受控访问** 。因为单例类封装了它的唯一实例，所以它可以严格控制客户怎样以及何时访问它。
  -  由于在系统内存中只存在一个对象，因此可以**节约系统资源**
- 缺点
  - 无抽象层，不利于扩展
  - 单例类职责过重
  - 现在很多面向对象语言（如Java、C#）的运行环境都提供了 **自动垃圾回收的技术**，因此，**如果实例化的共享对象长时间不被利用，系统会认为它是垃圾**，会自动销毁并回收资源，下次利用时又将重新实例化，这将导致共享的单例对象状态的丢失


##### 示例

```c#
public class SingleInstance
{
    private static class Holder
    {
        public static readonly SingleInstance instance = new SingleInstance();
    }
    public int count = 0;

    private SingleInstance()
    {
        Console.WriteLine("单例创建");
    }

    /// <summary>
    /// 实例获取方法
    /// </summary>
    /// <returns></returns>
    public static SingleInstance GetInstance()
    {
        // if(instance==null) instance = new SingleInstance();
        Holder.instance.count++;
        return Holder.instance;
    }
}
```



### 原型模式

##### 说明

- 

##### 优缺点

- 优点
  - 
- 缺点

##### 示例



### 建造者模式

##### 说明

- 

##### 优缺点

- 优点
  - 
- 缺点

##### 示例

------







# 结构型模式

### 适配器模式

##### 说明

- 

##### 优缺点

- 优点
  - 
- 缺点

##### 示例



### 桥接模式

##### 说明

- 

##### 优缺点

- 优点
  - 
- 缺点

##### 示例



### 组合模式



### 装饰模式



### 外观模式



### 享元模式



### 代理模式

------







# 行为模式

### 职责链模式



### 命令模式



### 解释器模式



### 迭代器模式



### 中介者模式



### 备忘录模式



### 观察者模式



### 状态模式



### 策略模式



### 模板方法模式



### 访问者模式