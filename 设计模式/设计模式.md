# 创建型模式

### 简单工厂模式

##### 说明

- 构造工厂类，在调用生产方法时 **传入不同参数来得到不同的产品类对象**
- 依赖于多态

##### 优缺点

- 优点

  - 实现了产品类 **对象创建和使用的分离**

    > 在工厂的生产方法中构造，在调用方法处使用

  - 要获取某个类的对象，只需要知道对应的参数即可

- 缺点

  - 需要引入工厂类

  - 如果要支持 **新的产品类**，需要 **修改生产方法**

    > 因为在生产方法中需要判断到底生成哪个产品类的对象

  - **生产方法为静态方法**，导致工厂类无法继承别的类

##### 示例

- 工厂类

  ```c#
  namespace DesignMethod
  {
      // 增加新产品，需要添加枚举值
      enum ProductIndex
      {
          Computer,
          Phone
      };
  
  
      /// <summary>
      /// 工厂类
      /// </summary>
      public class Factory
      {
          /// <summary>
          /// 生产方法：
          /// </summary>
          /// <returns>Product的子类对象</returns>
          public static Product GetProduct(int index)
          {
              Product ret = null;
              // 增加新产品，需要添加新的case判断
              switch(index)
              {
                  case (int)ProductIndex.Computer:
                      ret = new Computer();
                      break;
                  case (int)ProductIndex.Phone:
                      ret = new Phone();
                      break;
                  default:
                      Console.WriteLine("产品不存在");
                      break;
              }
  
              return ret;
          }
      }
  
  }
  ```

- 产品类
  ```c#
  namespace DesignMethod
  {
      /// <summary>
      /// 此文件保存产品类的定义
      /// </summary>
  
  
      /// <summary>
      /// 产品类抽象
      /// </summary>
      public abstract class Product
      {
          /// <summary>
          /// 产品名称
          /// </summary>
          /// <value>string</value>
          public abstract string Name{get;}
  
  
          /// <summary>
          /// 展示产品信息（）可重写
          /// </summary>
          public virtual void ShowInfo()
          {
              Console.WriteLine("被生产的产品名称：{0}",this.Name);
          }
      }
  
  
      /// <summary>
      /// 产品：电脑
      /// </summary>
      public class Computer : Product
      {
          public override string Name {get {return "Computer";}}
  
          public Computer()
          {
              ShowInfo();
          }
      }
  
  
      /// <summary>
      /// 产品：手机
      /// </summary>
      public class Phone : Product
      {
          public override string Name {get {return "Phone";}}
  
          public Phone()
          {
              ShowInfo();
          }
      }
  }
  ```

- 使用
  ```c#
  class Program
  {
      static void Main(string[] args)
      {
          testFactory();
  
      }
  
      public static void testFactory()
      {
          Product product = Factory.GetProduct(1);
         	// 被生产的产品名称：Phone
      }
  }
  ```

  

### 工厂方法模式

##### 说明

- 定义一个 **工厂接口**，让各个工厂类生产不同的产品
- 使用xml配置文件指定到底是哪个工厂类的对象进行生产

##### 优缺点

- 优点

  - 工厂方法用来创建客户所需要的产品，同时还向客户**隐藏了哪种具体产品类将被实例化这一细节**，用户**只需要关心所需产品对应的工厂**
  - 所有的具体工厂类都具有同一抽象父类，创建不同产品的细节被封装在各自对应的工厂类中
  - 添加新产品时，无序修改现有工厂的生产方法，只需添加新的产品类和对应的工厂类

- 缺点

  -  在添加新产品时，**需要编写新的具体产品类**，而且还要提供与之对应的具体工厂类，系统中类的个数将成对增加
  - 增加了系统的抽象性和理解难度，且在实现时可能需要用到DOM、反射等技术，增加了系统的实现难度

- 示例

  - Xml
    ```xml
    <?xml version="1.0" encoding="UTF-8"?>
    
    <!-- 通过xml文件指定生产的产品类型 -->
    
    <ProductList>
        <Product type="Phone">6888</Product>
        <Product type="Phone"></Product>
        <Product type="Computer">10000</Product>
        <Product type="Phone"></Product>
        <Product type="Computer"></Product>
    </ProductList>
    ```

  - 使用
    ```c#
    // 读取xml，根据配置生产对应产品
    Console.WriteLine("\n工厂方法：读配置生产");
    XmlDocument document = new XmlDocument();
    document.Load("/Users/dsh/Documents/C.Net/C#_onMac/designMethod/factory/Product.xml");
    XmlNode productListNode = document.SelectSingleNode("ProductList");
    // 读取子元素，创建对象
    Product[] products = new Product[productListNode.ChildNodes.Count];
    for(int i=0;i<products.Length;i++)
    {
        // 获取创建对象所需参数
        XmlElement productInfo = (XmlElement)productListNode.ChildNodes[i];
        string typeName = productInfo.GetAttribute("type");     // 产品类型名称
        string price = productInfo.InnerText;                   // 产品价格
        if(price.Length<1) price = "1";
        //反射
        Type type = Type.GetType("DesignMethod."+typeName);
        ConstructorInfo ctor = type.GetConstructor(new Type[]{typeof(float)});
        products[i] = (Product)ctor?.Invoke(new object[]{int.Parse(price)});
    }
    ```

    



### 抽象工厂模式

##### 说明

- 

##### 优缺点

- 优点
  - 
- 缺点

##### 示例



### 单例模式

##### 说明

- 

##### 优缺点

- 优点
  - 
- 缺点

##### 示例



### 原型模式

##### 说明

- 

##### 优缺点

- 优点
  - 
- 缺点

##### 示例



### 建造者模式

##### 说明

- 

##### 优缺点

- 优点
  - 
- 缺点

##### 示例

------







# 结构型模式

### 适配器模式

##### 说明

- 

##### 优缺点

- 优点
  - 
- 缺点

##### 示例



### 桥接模式

##### 说明

- 

##### 优缺点

- 优点
  - 
- 缺点

##### 示例



### 组合模式



### 装饰模式



### 外观模式



### 享元模式



### 代理模式

------







# 行为模式

### 职责链模式



### 命令模式



### 解释器模式



### 迭代器模式



### 中介者模式



### 备忘录模式



### 观察者模式



### 状态模式



### 策略模式



### 模板方法模式



### 访问者模式